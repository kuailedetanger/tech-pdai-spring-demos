## 一、什么样的场景需要访问外部接口？

通俗讲：**你的系统需要 “借力” 其他系统的数据 / 能力，自己无法实现或没必要实现**。

常见场景如下（表格 + 通俗解释）：

| 场景类型       | 通俗示例                                           | 核心诉求                                |
| -------------- | -------------------------------------------------- | --------------------------------------- |
| 第三方服务集成 | 调用微信支付 API 下单、调用阿里云短信 API 发验证码 | 对接成熟的商用服务，无需重复造轮子      |
| 微服务间通信   | 订单服务调用用户服务的 “查询用户信息” 接口         | 微服务拆分后，跨服务获取数据 / 触发操作 |
| 公共数据获取   | 调用天气 API 获取实时天气、调用地图 API 解析地址   | 获取公开的标准化数据                    |
| 上下游系统对接 | 电商系统调用仓储系统的 “库存扣减” 接口             | 企业内部不同系统间的协作                |

**图文类比**：

```plaintext
你的SpringBoot应用 → 相当于“消费者”
外部接口 → 相当于“便利店”
访问外部接口 → 你去便利店买东西（获取商品/服务）
```

## 二、访问外部接口的常见方案（对比 + 选型）

SpringBoot 中访问外部接口有 3 类核心方案，各有适配场景，先通过表格对比，再逐个拆解：

| 方案类型                     | 核心原理                                  | 优点                                      | 缺点                                          | 适用场景                                 |
| ---------------------------- | ----------------------------------------- | ----------------------------------------- | --------------------------------------------- | ---------------------------------------- |
| 原生 HTTP 请求（JDK/OkHttp） | 手动构建 HTTP 请求、处理连接、解析响应    | 轻量、无依赖、灵活度极高                  | 代码冗余、需手动处理异常 / 重试 / 超时        | 简单场景、对依赖体积敏感（如小型工具）   |
| RestTemplate（Spring 内置）  | 封装原生 HTTP，提供简洁的 API（get/post） | 上手快、支持多种请求类型、Spring 原生集成 | 同步调用、功能较基础（无内置熔断 / 负载均衡） | 单体应用、简单微服务场景（中小项目首选） |
| Feign（声明式 HTTP 客户端）  | 基于接口注解生成代理，自动封装 HTTP 请求  | 代码极简（声明式）、支持负载均衡 / 熔断   | 依赖 Spring Cloud、学习成本略高               | 微服务架构（Spring Cloud 体系首选）      |

**核心关系图**：

```plaintext
【底层基础】原生HTTP请求（JDK HttpURLConnection/OkHttp）
          ↓ （Spring封装）
【基础封装】RestTemplate
          ↓ （声明式封装+微服务增强）
【微服务专属】Feign
```

## 三、各方案实操详解

### 方案一：原生 HTTP 请求（极简示例）

原生方案分两种：JDK 自带的`HttpURLConnection`（基础但繁琐）、第三方的`OkHttp`（推荐，更简洁）。

#### 1. OkHttp 实操（推荐）

##### 步骤 1：引入依赖



```xml
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>4.12.0</version>
</dependency>
```

##### 步骤 2：GET 请求示例



```java
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import java.io.IOException;

public class OkHttpDemo {
    public static void main(String[] args) throws IOException {
        // 1. 创建客户端
        OkHttpClient client = new OkHttpClient();
        // 2. 构建请求（外部接口URL）
        Request request = new Request.Builder()
                .url("https://api.github.com/users/octocat") // 外部接口地址
                .get() // GET请求
                .build();
        // 3. 发送请求并获取响应
        try (Response response = client.newCall(request).execute()) {
            // 4. 解析响应
            if (response.isSuccessful()) {
                System.out.println(response.body().string());
            }
        }
    }
}
```

##### 步骤 3：POST 请求示例



```java
import okhttp3.MediaType;
import okhttp3.RequestBody;

// 定义JSON媒体类型
public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");

public String post(String url, String json) throws IOException {
    OkHttpClient client = new OkHttpClient();
    // 构建POST请求体（JSON格式）
    RequestBody body = RequestBody.create(json, JSON);
    Request request = new Request.Builder()
            .url(url)
            .post(body)
            .build();
    try (Response response = client.newCall(request).execute()) {
        return response.body().string();
    }
}

// 调用示例
post("https://api.example.com/create", "{\"name\":\"test\",\"age\":20}");
```

#### 2. 核心缺点

- 每个请求都要写 “创建客户端→构建请求→发送→解析” 的重复代码；
- 需手动处理超时、重试、异常捕获，代码冗余。

### 方案二：Feign（声明式消费，微服务首选）

Feign 是 Spring Cloud 的组件，核心是 “**写接口 = 调接口**”，无需手动构建 HTTP 请求。

#### 1. 实操步骤

##### 步骤 1：引入依赖（需 Spring Cloud 环境）

```xml
<!-- Feign核心依赖 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
<!-- 负载均衡（可选，微服务必备） -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

##### 步骤 2：启动类开启 Feign

```java
@SpringBootApplication
@EnableFeignClients // 开启Feign扫描
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

##### 步骤 3：定义 Feign 接口（核心）

```java
// 声明要调用的外部服务（微服务名/直接写URL）
@FeignClient(name = "user-service", url = "http://localhost:8081") // url为外部接口地址
public interface UserFeignClient {
    // GET请求：调用用户服务的查询接口
    @GetMapping("/api/user/{id}")
    UserVO getUserById(@PathVariable("id") Long id);

    // POST请求：调用用户服务的创建接口
    @PostMapping("/api/user")
    Result<Long> createUser(@RequestBody UserDTO userDTO);
}
```

##### 步骤 4：注入使用

```java
@RestController
public class OrderController {
    @Autowired
    private UserFeignClient userFeignClient;

    @GetMapping("/order/{userId}")
    public Result<OrderVO> getOrder(@PathVariable Long userId) {
        // 调用外部接口（通过Feign）
        UserVO user = userFeignClient.getUserById(userId);
        return Result.success(new OrderVO(1001, user.getName(), 99.0));
    }
}
```

#### 2. 核心优势

- 声明式编程：只需定义接口 + 注解，无需写 HTTP 请求代码；
- 微服务友好：支持服务名调用（配合 Nacos/Eureka）、负载均衡；
- 易扩展：可通过拦截器添加请求头、配置超时 / 重试。

### 方案三：RestTemplate（Spring 内置，单体 / 简单微服务首选）

RestTemplate 是 Spring 封装的 HTTP 客户端，比原生简洁，比 Feign 更轻量（无需 Spring Cloud）。

#### 1. 先配置 RestTemplate Bean

```java
@Configuration
public class RestTemplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        // 可自定义配置（超时、拦截器等）
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(5000); // 连接超时5秒
        factory.setReadTimeout(5000); // 读取超时5秒
        return new RestTemplate(factory);
    }
}
```

#### 2. GET 请求详解

RestTemplate 的 GET 请求有 2 类核心方法：`getForEntity`（返回完整响应）、`getForObject`（直接返回响应体）。

##### （1）getForEntity(String url, Class<T> responseType, Object... urlVariables)

- 作用：带 URL 参数的 GET 请求，返回包含响应头、状态码、响应体的完整对象；
- 示例：



```java
@Autowired
private RestTemplate restTemplate;

// 外部接口URL（{1}为参数占位符）
String url = "https://api.github.com/users/{1}";
// 发送GET请求（参数：url、响应类型、URL占位符值）
ResponseEntity<String> response = restTemplate.getForEntity(url, String.class, "octocat");

// 解析响应
int statusCode = response.getStatusCodeValue(); // 状态码（200）
HttpHeaders headers = response.getHeaders(); // 响应头
String body = response.getBody(); // 响应体（JSON字符串）
```

##### （2）getForEntity(URI url, Class<T> responseType)

- 作用：通过 URI 对象构建请求（适合复杂参数，如多参数、特殊字符）；
- 示例：



```java
// 构建URI（含参数）
URI uri = UriComponentsBuilder.fromUriString("https://api.example.com/user")
        .queryParam("id", 1001)
        .queryParam("name", "test")
        .build()
        .toUri();
// 发送请求
ResponseEntity<UserVO> response = restTemplate.getForEntity(uri, UserVO.class);
UserVO user = response.getBody();
```

##### （3）getForObject（简化版）

- 作用：直接返回响应体（省略响应头 / 状态码），代码更简洁；
- 示例：





```java
// 直接获取UserVO对象（无需解析ResponseEntity）
UserVO user = restTemplate.getForObject("https://api.example.com/user/{1}", UserVO.class, 1001);
```

#### 3. POST 请求详解

RestTemplate 的 POST 请求核心方法：`postForEntity`、`postForObject`、`postForLocation`。

##### 示例（JSON 请求体）：



```java
// 外部接口URL
String url = "https://api.example.com/user";
// 构建请求体
UserDTO userDTO = new UserDTO("test", 20);
// 发送POST请求（JSON格式）
ResponseEntity<Result<Long>> response = restTemplate.postForEntity(
        url,
        userDTO, // 请求体
        Result.class // 响应类型
);
// 解析响应
Long userId = response.getBody().getData();
```

##### 关键说明：

- RestTemplate 默认会把 Java 对象转为 JSON 请求体（依赖 Jackson）；
- 如果是表单提交，需构建`MultiValueMap`作为请求体：

```java
MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
formData.add("username", "test");
formData.add("password", "123456");
ResponseEntity<Result> response = restTemplate.postForEntity(url, formData, Result.class);
```

## 四、接口调用中的核心注意事项（避坑指南）

### 1. 超时控制（必配）

- 问题：外部接口响应慢会导致你的应用线程阻塞；
- 解决方案：
  - RestTemplate：配置`connectTimeout`/`readTimeout`；
  - OkHttp：配置`callTimeout`/`connectTimeout`；
  - Feign：配置`feign.client.config.default.connectTimeout`/`readTimeout`。

### 2. 异常处理（必做）

| 异常类型                 | 场景                            | 处理方式                  |
| ------------------------ | ------------------------------- | ------------------------- |
| ConnectTimeoutException  | 连接超时（外部服务不可达）      | 重试 + 告警，避免雪崩     |
| HttpClientErrorException | 4xx 错误（参数错误 / 权限不足） | 解析响应体，返回友好提示  |
| HttpServerErrorException | 5xx 错误（外部服务异常）        | 熔断 / 降级，返回兜底数据 |

**示例（RestTemplate 异常处理）**：

```java
try {
    UserVO user = restTemplate.getForObject(url, UserVO.class, 1001);
} catch (ConnectTimeoutException e) {
    log.error("连接外部接口超时：{}", url, e);
    return Result.fail("服务暂不可用");
} catch (HttpClientErrorException e) {
    log.error("外部接口返回4xx错误：{}，响应体：{}", url, e.getResponseBodyAsString());
    return Result.fail("参数错误");
}
```

### 3. 重试机制（可选）

- 场景：外部接口偶发失败（网络抖动）；
- 解决方案：使用`spring-retry`实现重试：



```xml
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
</dependency>
```



```java
@Retryable(value = {ConnectTimeoutException.class}, maxAttempts = 3, backoff = @Backoff(delay = 1000))
public UserVO getUser(Long id) {
    return restTemplate.getForObject(url, UserVO.class, id);
}

// 重试失败后的兜底方法
@Recover
public UserVO recover(ConnectTimeoutException e, Long id) {
    log.error("重试3次仍失败", e);
    return new UserVO(); // 兜底数据
}
```

### 4. 熔断降级（微服务必备）

- 场景：外部服务故障，避免拖垮你的应用；
- 解决方案：使用 Sentinel/Hystrix，配置熔断规则（如失败率超过 50% 则熔断）。

### 5. 请求头 / 认证（常见）

- 场景：外部接口需要 token/API Key 认证；
- 示例（RestTemplate 添加请求头）：

```java
HttpHeaders headers = new HttpHeaders();
headers.set("Authorization", "Bearer " + token);
headers.setContentType(MediaType.APPLICATION_JSON);
HttpEntity<UserDTO> request = new HttpEntity<>(userDTO, headers);
ResponseEntity<Result> response = restTemplate.postForEntity(url, request, Result.class);
```

### 6. 数据校验（双向）

- 调用前：校验请求参数（非空 / 格式），避免无效调用；
- 调用后：校验响应数据（非空 / 格式），避免解析异常。

## 五、总结（选型建议）

| 项目类型              | 推荐方案     | 核心理由                                    |
| --------------------- | ------------ | ------------------------------------------- |
| 单体应用 / 小型项目   | RestTemplate | 上手快、无额外依赖、满足大部分需求          |
| Spring Cloud 微服务   | Feign        | 声明式编程、支持负载均衡 / 熔断，适配微服务 |
| 轻量工具 / 低依赖场景 | OkHttp       | 体积小、性能优、灵活度高                    |

**核心原则**：

- 优先选封装度高的方案（Feign > RestTemplate > 原生 HTTP），减少重复代码；
- 必须配置超时、异常处理，避免外部接口故障影响自身应用；
- 微服务场景一定要做熔断 / 降级，防止雪崩。

