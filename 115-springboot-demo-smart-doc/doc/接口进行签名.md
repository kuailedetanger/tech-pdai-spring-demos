## 一、先搞懂：API 接口的不安全因素（通俗 + 表格）

接口暴露在网络中，就像 “家门没锁”，容易被攻击，核心风险如下：

| 安全风险类型         | 通俗解释                                              | 业务危害           |
| -------------------- | ----------------------------------------------------- | ------------------ |
| 接口参数篡改         | 攻击者拦截请求，修改参数（如把支付金额从 100 改成 1） | 资损、数据错误     |
| 请求伪造（仿冒调用） | 攻击者冒充合法客户端调用接口（如伪造下单请求）        | 数据泄露、恶意操作 |
| 重放攻击             | 攻击者截取合法请求，重复调用（如重复下单、重复扣款）  | 重复创建数据、资损 |
| 明文传输泄露         | 接口参数明文传输，被抓包获取（如账号、密码、token）   | 敏感信息泄露       |
| 未授权访问           | 攻击者调用未授权的接口（如普通用户调用管理员接口）    | 越权操作、数据泄露 |

**图文类比**：

```plaintext
【无防护接口】
客户端 → 明文请求（金额=100）→ 网络传输（被拦截篡改）→ 服务端（接收金额=1）→ 扣1元（资损）

【签名防护接口】
客户端 → 签名请求（金额=100 + 签名=加密串）→ 网络传输（篡改后签名不匹配）→ 服务端（验证签名失败→拒绝）
```

## 二、常见的保证接口安全的方式（对比 + 选型）

接口安全防护是 “组合拳”，签名是核心，需配合其他手段，先看主流方案对比：

| 安全方式                 | 核心原理                                  | 解决的风险               | 局限性                       |
| ------------------------ | ----------------------------------------- | ------------------------ | ---------------------------- |
| HTTPS 协议               | 传输层加密，防止明文抓包                  | 明文传输泄露             | 无法防止参数篡改、重放攻击   |
| AccessKey&SecretKey 认证 | 分配唯一 AK/SK，标识调用方身份            | 未授权访问               | 仅认证身份，无法防篡改、重放 |
| 接口签名（加密）         | 对请求参数 + 密钥加密生成签名，服务端验签 | 参数篡改、伪造、重放攻击 | 需配合时间戳 /nonce 防重放   |
| Token 认证（JWT/OAuth2） | 颁发临时令牌，接口携带令牌访问            | 未授权访问               | 令牌泄露仍可能被冒用         |
| IP 白名单                | 仅允许指定 IP 调用接口                    | 未授权访问、伪造请求     | 灵活性差，不适合公网接口     |

### 核心结论：

接口签名不是 “单独使用”，而是**HTTPS + AK/SK + 签名 + 时间戳 /nonce** 的组合方案，覆盖 “身份认证、防篡改、防重放、防泄露” 全维度。

## 三、AccessKey&SecretKey + 接口签名核心原理

### 1. 基础概念（通俗讲）

- **AccessKey（AK）**：调用方的唯一身份标识（类似 “用户名”），明文传输；
- **SecretKey（SK）**：调用方的密钥（类似 “密码”），仅客户端和服务端知晓，**绝不传输**；
- **接口签名**：将 “请求参数 + 时间戳 + nonce（随机串）” 按规则拼接，用 SK 加密生成签名，服务端按相同规则验签。

### 2. 签名核心流程（图文）

```plaintext
【客户端步骤】
Step1：获取服务端分配的AK/SK；
Step2：构造请求参数（如orderId=1001、amount=100）；
Step3：生成nonce（随机串）、timestamp（时间戳，如1734364800000）；
Step4：参数排序（按key升序）→ 拼接成字符串：amount=100&nonce=abc&orderId=1001&timestamp=1734364800000；
Step5：拼接SK → 字符串+SK：amount=100&nonce=abc&orderId=1001&timestamp=1734364800000&sk=xxx；
Step6：加密（如MD5/SHA256）→ 生成签名sign=xxx；
Step7：发送请求：参数（AK、orderId、amount、nonce、timestamp）+ sign → 服务端；

【服务端步骤】
Step1：校验AK是否合法（查询数据库）；
Step2：校验timestamp是否过期（如超过5分钟则拒绝，防重放）；
Step3：校验nonce是否已使用（Redis记录，防重放）；
Step4：按客户端相同规则拼接参数+SK，生成服务端签名；
Step5：对比客户端sign和服务端sign：
       - 一致 → 验签通过，执行业务；
       - 不一致 → 验签失败，拒绝请求；
Step6：将nonce存入Redis（设置过期时间=时间戳有效期）。
```

### 3. 关键防重放设计

- **时间戳（timestamp）**：限制请求有效期（如 5 分钟），超过则直接拒绝，防止攻击者长期保存请求重放；
- **Nonce（随机串）**：每次请求生成唯一随机串，服务端记录已使用的 nonce，防止相同请求重复调用。



## 四、SpringBoot 接口签名实现案例（完整实操）

### 核心思路：

通过**自定义注解 + AOP 拦截** 实现签名校验，做到 “无侵入式”—— 只需给需要签名的接口加注解，即可自动验签。

### 步骤 1：核心依赖（pom.xml）

```xml
<!-- SpringBoot核心 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- AOP -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
<!-- Redis（存nonce防重放） -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!-- 加密工具 -->
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.15</version>
</dependency>
```

### 步骤 2：自定义注解（标记需要签名的接口）

java

```java
/**
 * 接口签名注解：加在需要验签的Controller/方法上
 */
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface ApiSign {
    // 签名有效期（默认5分钟，单位：秒）
    long expireTime() default 300;
}
```

### 步骤 3：Request 封装（统一获取请求参数）

需兼容 GET（参数在 URL）、POST（参数在 Body / 表单）的参数获取，核心工具类：

```java
@Component
public class RequestParamUtil {

    @Autowired
    private HttpServletRequest request;

    /**
     * 统一获取所有请求参数（GET/POST）
     */
    public Map<String, String> getAllParams() throws IOException {
        Map<String, String> params = new HashMap<>();
        String method = request.getMethod();

        // 1. GET请求：获取URL参数
        if ("GET".equalsIgnoreCase(method)) {
            Map<String, String[]> parameterMap = request.getParameterMap();
            for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
                params.put(entry.getKey(), entry.getValue()[0]);
            }
        }
        // 2. POST请求：兼容表单/JSON
        else if ("POST".equalsIgnoreCase(method)) {
            String contentType = request.getContentType();
            // 表单提交
            if (contentType != null && contentType.contains("form")) {
                Map<String, String[]> parameterMap = request.getParameterMap();
                for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
                    params.put(entry.getKey(), entry.getValue()[0]);
                }
            }
            // JSON提交
            else if (contentType != null && contentType.contains("json")) {
                BufferedReader reader = request.getReader();
                StringBuilder sb = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    sb.append(line);
                }
                // JSON转Map（需引入fastjson/jackson）
                ObjectMapper objectMapper = new ObjectMapper();
                Map<String, String> jsonMap = objectMapper.readValue(sb.toString(), new TypeReference<Map<String, String>>() {});
                params.putAll(jsonMap);
            }
        }
        return params;
    }
}
```

### 步骤 4：签名工具类（生成 / 验证签名）

java

```java
@Component
public class SignUtil {

    // 加密算法（MD5/SHA256，推荐SHA256）
    private static final String ALGORITHM = "SHA-256";

    /**
     * 生成签名
     * @param params 请求参数（不含sign）
     * @param sk 密钥
     * @return 签名串
     */
    public String generateSign(Map<String, String> params, String sk) {
        // 1. 排序参数（按key升序）
        List<String> keyList = new ArrayList<>(params.keySet());
        Collections.sort(keyList);

        // 2. 拼接参数字符串
        StringBuilder sb = new StringBuilder();
        for (String key : keyList) {
            String value = params.get(key);
            if (value != null && !value.isEmpty()) {
                sb.append(key).append("=").append(value).append("&");
            }
        }
        // 3. 拼接SK（去掉最后一个&）
        String signStr = sb.substring(0, sb.length() - 1) + "&sk=" + sk;

        // 4. 加密生成签名
        try {
            MessageDigest digest = MessageDigest.getInstance(ALGORITHM);
            byte[] hash = digest.digest(signStr.getBytes(StandardCharsets.UTF_8));
            // 转16进制字符串
            return Hex.encodeHexString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("签名生成失败", e);
        }
    }

    /**
     * 验证签名
     * @param params 请求参数（含sign）
     * @param sk 密钥
     * @param clientSign 客户端签名
     * @return 是否验证通过
     */
    public boolean verifySign(Map<String, String> params, String sk, String clientSign) {
        // 移除sign参数（避免参与签名）
        Map<String, String> copyParams = new HashMap<>(params);
        copyParams.remove("sign");
        // 生成服务端签名
        String serverSign = generateSign(copyParams, sk);
        // 对比签名（忽略大小写）
        return serverSign.equalsIgnoreCase(clientSign);
    }
}
```

### 步骤 5：AOP 拦截器（核心验签逻辑）



```java
@Aspect
@Component
@Slf4j
public class ApiSignAop {

    @Autowired
    private RequestParamUtil requestParamUtil;
    @Autowired
    private SignUtil signUtil;
    @Autowired
    private StringRedisTemplate redisTemplate;
    // 模拟AK-SK配置（实际应从数据库/配置中心获取）
    private final Map<String, String> akSkMap = new HashMap<String, String>() {{
        put("test_ak", "test_sk123456"); // 测试AK-SK
    }};

    // 切点：加了@ApiSign注解的方法/类
    @Pointcut("@annotation(com.example.demo.annotation.ApiSign) || @within(com.example.demo.annotation.ApiSign)")
    public void signPointcut() {}

    // 环绕通知：验签逻辑
    @Around("signPointcut()")
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        // 1. 获取请求参数
        Map<String, String> params = requestParamUtil.getAllParams();

        // 2. 校验必传参数（ak、timestamp、nonce、sign）
        checkRequiredParams(params);

        // 3. 解析参数
        String ak = params.get("ak");
        String timestamp = params.get("timestamp");
        String nonce = params.get("nonce");
        String clientSign = params.get("sign");
        // 获取注解的过期时间
        long expireTime = getExpireTime(joinPoint);

        // 4. 校验AK是否合法
        String sk = akSkMap.get(ak);
        if (sk == null) {
            throw new RuntimeException("非法的AccessKey");
        }

        // 5. 校验时间戳是否过期
        checkTimestamp(timestamp, expireTime);

        // 6. 校验nonce是否重复（防重放）
        checkNonce(nonce, expireTime);

        // 7. 验证签名
        boolean verifyResult = signUtil.verifySign(params, sk, clientSign);
        if (!verifyResult) {
            throw new RuntimeException("签名验证失败");
        }

        // 8. 验签通过，执行原方法
        return joinPoint.proceed();
    }

    /**
     * 校验必传参数
     */
    private void checkRequiredParams(Map<String, String> params) {
        List<String> required = Arrays.asList("ak", "timestamp", "nonce", "sign");
        for (String param : required) {
            if (!params.containsKey(param) || params.get(param).isEmpty()) {
                throw new RuntimeException("缺少必传参数：" + param);
            }
        }
    }

    /**
     * 校验时间戳是否过期
     */
    private void checkTimestamp(String timestampStr, long expireTime) {
        try {
            long timestamp = Long.parseLong(timestampStr);
            long now = System.currentTimeMillis();
            // 超过过期时间则拒绝
            if (Math.abs(now - timestamp) > expireTime * 1000) {
                throw new RuntimeException("请求已过期");
            }
        } catch (NumberFormatException e) {
            throw new RuntimeException("时间戳格式错误");
        }
    }

    /**
     * 校验nonce是否重复
     */
    private void checkNonce(String nonce, long expireTime) {
        String redisKey = "api:nonce:" + nonce;
        // 已存在则重复
        Boolean exists = redisTemplate.hasKey(redisKey);
        if (Boolean.TRUE.equals(exists)) {
            throw new RuntimeException("重复的请求（nonce已使用）");
        }
        // 存入Redis，设置过期时间
        redisTemplate.opsForValue().set(redisKey, "1", expireTime, TimeUnit.SECONDS);
    }

    /**
     * 获取注解的过期时间
     */
    private long getExpireTime(ProceedingJoinPoint joinPoint) {
        // 先获取方法上的注解
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        ApiSign methodAnnotation = signature.getMethod().getAnnotation(ApiSign.class);
        if (methodAnnotation != null) {
            return methodAnnotation.expireTime();
        }
        // 再获取类上的注解
        Class<?> targetClass = joinPoint.getTarget().getClass();
        ApiSign classAnnotation = targetClass.getAnnotation(ApiSign.class);
        if (classAnnotation != null) {
            return classAnnotation.expireTime();
        }
        // 默认5分钟
        return 300;
    }
}
```

### 步骤 6：接口测试（Controller）

```java
@RestController
@RequestMapping("/api/order")
@ApiSign // 类级别加注解，所有方法都验签
public class OrderController {

    /**
     * 下单接口（需要签名）
     */
    @PostMapping("/create")
    public Result<String> createOrder(
            @RequestParam String orderId,
            @RequestParam BigDecimal amount) {
        // 业务逻辑：创建订单
        log.info("创建订单成功，orderId：{}，amount：{}", orderId, amount);
        return Result.success("订单创建成功，orderId：" + orderId);
    }

    /**
     * 查询接口（自定义过期时间10分钟）
     */
    @GetMapping("/query")
    @ApiSign(expireTime = 600) // 方法级别注解，覆盖类级别
    public Result<Map<String, Object>> queryOrder(@RequestParam String orderId) {
        Map<String, Object> order = new HashMap<>();
        order.put("orderId", orderId);
        order.put("amount", new BigDecimal("100.00"));
        order.put("status", "待支付");
        return Result.success(order);
    }
}
```

### 步骤 7：测试示例（Postman 调用）

#### 1. 构造请求参数

- AK：test_ak
- orderId：20251216001
- amount：100.00
- timestamp：1734364800000（当前时间戳）
- nonce：abc123（随机串）

#### 2. 生成签名

- 排序参数：amount=100.00&nonce=abc123&orderId=20251216001&timestamp=1734364800000
- 拼接 SK：amount=100.00&nonce=abc123&orderId=20251216001&timestamp=1734364800000&sk=test_sk123456
- SHA256 加密：生成签名（如：7e8f3b9a8d7c6b5a4f3e2d1c0b9a8s7d6f5e4d3c2b1a0987654321）

#### 3. Postman 请求

- 请求地址：`http://localhost:8080/api/order/create`

- 请求方式：POST

- 参数（Form/JSON）：

  plaintext

  

  

  

  

  

  ```plaintext
  ak=test_ak
  orderId=20251216001
  amount=100.00
  timestamp=1734364800000
  nonce=abc123
  sign=7e8f3b9a8d7c6b5a4f3e2d1c0b9a8s7d6f5e4d3c2b1a0987654321
  ```

  

- 响应：`{"code":200,"msg":"成功","data":"订单创建成功，orderId：20251216001"}`

#### 4. 异常测试

- 篡改 amount 为 1：签名验证失败，返回 “签名验证失败”；
- 重复使用 nonce=abc123：返回 “重复的请求（nonce 已使用）”；
- 时间戳过期：返回 “请求已过期”。

## 五、核心注意事项（避坑指南）

### 1. 签名规则必须前后端一致

- 参数排序规则（升序 / 降序）、拼接分隔符（&）、加密算法（SHA256/MD5）必须前后端完全一致，否则签名验证失败；
- 空值参数处理：建议忽略空值，避免前后端对空值的处理差异导致签名不一致。

### 2. 密钥安全

- SK 绝不传输、绝不明文存储（服务端建议加密存储，如 AES 加密）；
- 定期更换 AK/SK，避免密钥泄露；
- 禁止在日志中打印 SK、签名等敏感信息。

### 3. 防重放细节

- nonce 的 Redis 过期时间需和时间戳有效期一致，避免 Redis 堆积大量无效 key；
- 时间戳建议用毫秒级，避免秒级精度导致的重复请求。

### 4. 性能优化

- 签名验证是 CPU 密集型操作，高并发场景可缓存 AK-SK（如本地缓存 + Redis），减少数据库查询；

- nonce 的 Redis 操作建议用 “SET NX”（原子操作），避免并发问题：

  java

  

  运行

  

  

  

  

  ```java
  Boolean success = redisTemplate.opsForValue().setIfAbsent(redisKey, "1", expireTime, TimeUnit.SECONDS);
  if (!Boolean.TRUE.equals(success)) {
      throw new RuntimeException("重复的请求");
  }
  ```

  

## 六、总结（核心要点）

| 核心环节 | 关键动作                                              |
| -------- | ----------------------------------------------------- |
| 签名设计 | 参数排序 + 密钥加密 + 时间戳 /nonce 防重放            |
| 落地方式 | 注解 + AOP 无侵入式验签                               |
| 安全组合 | HTTPS（防泄露）+ AK/SK（认证）+ 签名（防篡改 / 重放） |
| 避坑核心 | 前后端签名规则一致、SK 绝不传输、防重放机制必加       |

接口签名的核心不是 “加密有多复杂”，而是 “规则统一、防篡改、防重放、身份认证”—— 只要能杜绝 “参数被改、请求被仿、请求被重放”，就是有效的签名方案。





















# 解惑

## 1.AccessKey&SecretKey和传统的 userName 和password 有什么区别吗？

AccessKey&SecretKey 和传统的 userName&password 是两种**不同身份认证体系**的凭证，核心区别在于**设计目标、使用场景、安全性和权限管控**，可以用 “普通人开锁” 和 “专业设备开锁” 的类比来理解：

| 维度         | **AccessKey&SecretKey（AK/SK）**                             | **userName&password（用户名密码）**                          |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **设计目标** | 面向**程序 / 服务间的自动化调用**                            | 面向**人直接登录系统**的交互场景                             |
| **使用主体** | 机器（服务、脚本、SDK）                                      | 人类用户                                                     |
| **安全性**   | 1. 无状态，不存储在服务端会话2. 通常基于**签名机制**（如 HMAC-SHA256），SK 不会在网络中传输3. 支持**短期临时凭证**（如 STS 令牌） | 1. 常基于会话认证，易被会话劫持2. 密码通常明文传输（需 HTTPS 加密）或简单哈希3. 多为长期凭证，泄露风险高 |
| **权限管控** | 精细化权限绑定，可按**最小权限原则**配置（如仅允许读取 OBS 桶、仅允许调用某 API） | 权限通常与用户角色绑定，颗粒度较粗（如管理员 / 普通用户）    |
| **使用方式** | 嵌入代码、配置文件或环境变量，自动签名请求，无需人工干预     | 人工手动输入，需配合验证码、双因素认证等增强安全             |
| **泄露影响** | 可快速**禁用 / 轮换**，且因权限可控，影响范围有限            | 泄露后需修改密码，且可能导致全量权限被盗用                   |
| **典型场景** | 云服务 API 调用、微服务间通信、第三方集成（如 OSS 上传、支付接口） | 网站登录、APP 登录、操作系统登录                             |

### 核心差异拆解

1. **身份主体不同**
   - 用户名密码是**人的身份凭证**，比如你登录淘宝、微信时输入的账号密码，是为了证明 “你是你”。
   - AK/SK 是**程序的身份凭证**，比如你的 Java 后端服务调用阿里云 OSS 存储时，不会让人工输入密码，而是通过 AK/SK 让阿里云识别 “这个服务是合法的”。
2. **安全机制不同**
   - 用户名密码的核心是 **“验证凭证本身”**：服务端存储密码哈希值，用户输入后对比哈希是否一致。如果密码在传输中被截获（即使是 HTTPS，也存在终端泄露风险），就会被盗用。
   - AK/SK 的核心是 **“验证请求签名”**：SK 不会在网络中传输，程序会用 SK 对请求参数（如时间戳、请求内容）进行加密签名，服务端用对应的 AK 获取 SK 后，重新计算签名并对比。即使请求被截获，攻击者没有 SK 也无法伪造请求。
3. **权限粒度不同**
   - 用户名密码的权限通常和用户角色强绑定，比如一个 “运营用户” 可能拥有查看订单、修改商品的权限，无法拆分。
   - AK/SK 可以做到**极致的权限精细化**，比如为某个后端服务配置的 AK/SK，只允许它调用 “查询订单列表” 的 API，且只能查询某一个商户的订单，符合**最小权限原则**，降低泄露风险。

### 举个 Java 开发中的实际例子

- 如果你用 Spring Boot 开发一个电商系统，**管理员登录后台**时，用的是 **用户名 + 密码**，验证通过后分配会话 Cookie。

- 你的系统需要

  调用阿里云 OSS 上传商品图片

  时，会在 application.yml 中配置 AK/SK：

  ```yaml
  aliyun:
    oss:
      access-key: LTAI5txxxxxxxxxxxxxxxxx
      secret-key: 8kxxxxxxxxxxxxxxxxxxxxxx
      endpoint: oss-cn-hangzhou.aliyuncs.com
  ```

  

  程序会用 SK 对上传请求进行签名，阿里云验证签名合法后，才允许上传，全程无需人工干预。

### 总结

- **用户名密码**：为人设计，侧重 “身份验证”，适合人工交互场景。
- **AK/SK**：为机器设计，侧重 “请求签名验证”，适合自动化服务调用，安全性更高、权限更精细。

在 Java 后端开发中，**绝对不要用用户名密码代替 AK/SK** 来调用第三方服务，否则会导致密码硬编码泄露、权限过大等严重安全问题。





2：时间戳 + Nonce 防重放

## 

先给结论：**时间戳 + Nonce 是专门解决 “重放攻击” 的组合拳**—— 重放攻击就是攻击者把你发过的合法请求 “抄一遍”，重复提交给服务端（比如截获你的下单请求后，反复调用刷订单），而时间戳和 Nonce 能从 “时间范围 + 唯一标识” 两个维度，让重复请求失效。

## 一、先搞懂：什么是重放攻击？（通俗类比）

### 生活类比

你去咖啡店买咖啡，付款时给收银员看了 “付款成功” 的截图（合法请求），如果收银员不核对截图的 “时间” 和 “订单号”，你就能用这张截图反复领咖啡 —— 这就是 “重放攻击”。

### 接口场景类比

```plaintext
【正常流程】
你 → 调用下单接口（参数：金额100+签名）→ 服务端验证通过 → 生成1笔订单

【重放攻击】
攻击者 → 截获你的下单请求 → 重复调用该请求 → 服务端无防护 → 生成多笔订单（资损）
```

## 二、时间戳 + Nonce：为什么能防重放？（拆解作用）

把两个字段的作用拆开讲，你就能秒懂：

### 1. 时间戳（Timestamp）：给请求加 “有效期”

#### 通俗解释

给每个请求贴一个 “发送时间标签”，服务端规定：**只有在有效期内的请求才处理，过期直接拒绝**。

比如设置有效期 5 分钟，你的请求时间戳是`1734364800000`（2025-12-16 10:00:00），攻击者 10:06 才重放这个请求，服务端一看 “时间超了”，直接拒绝。

#### 核心逻辑（图文）

```plaintext
客户端 → 生成当前时间戳（如1734364800000）→ 随请求发送
服务端 → 对比“当前时间 - 请求时间戳”：
   → 差值 ≤ 5分钟 → 继续处理；
   → 差值 ＞ 5分钟 → 拒绝（请求过期）。
```

#### 为什么需要它？

攻击者截获请求后，不可能无限期保存，短有效期能让 “旧请求” 失效 —— 比如 5 分钟有效期，攻击者哪怕截获了请求，只要超过 5 分钟，重放也没用。

### 2. Nonce（随机串）：给请求加 “唯一身份证”

#### 通俗解释

Nonce 是 “Number Used Once” 的缩写，意思是 “仅使用一次的随机数”—— 每个请求生成一个独一无二的随机串（比如`a897f6b5-9876-4d5c-8765-9876f5e4d3c2`），服务端收到后，先查这个随机串是否 “用过”，用过就拒绝，没用过就标记为 “已用”。

#### 核心逻辑（图文）

```plaintext
客户端 → 生成唯一Nonce（如a897f6b5...）→ 随请求发送
服务端 → 查Redis（存已用Nonce）：
   → Nonce已存在 → 拒绝（重复请求）；
   → Nonce不存在 → 存入Redis（设置过期时间=时间戳有效期）→ 继续处理。
```

#### 为什么需要它？

时间戳只能防 “过期请求”，但如果攻击者在 5 分钟内重放请求（比如 1 分钟后就重放），时间戳拦不住 —— 而 Nonce 能保证 “哪怕同一时间范围内，相同请求也只能执行一次”。

## 三、时间戳 + Nonce：组合使用的核心逻辑（一步一步讲）

Nonce 是英文 “Number Used Once” 的缩写，核心直译是 **“仅使用一次的数字”**，在接口安全场景中，行业内常见的中文译法 / 表述有：

1. **一次性随机数**（最贴合原意，也是最常用的译法）；
2. **临时随机串**（强调 “临时” 和 “随机” 属性）；
3. **唯一一次性标识**（突出 “唯一” 和 “仅用一次” 的核心特征）。

用下单接口的例子，完整走一遍流程，你就全懂了：

### 步骤 1：客户端发起请求（加时间戳 + Nonce）

1. 客户端生成当前时间戳：`1734364800000`（2025-12-16 10:00:00）；
2. 客户端生成唯一 Nonce：`abc123def456`；
3. 客户端把 “金额 = 100 + 时间戳 + Nonce+AK” 按规则拼接，用 SK 加密生成签名；
4. 客户端发送请求：`金额=100&timestamp=1734364800000&nonce=abc123def456&ak=test&sign=xxx`。

### 步骤 2：服务端验证（先拦重放，再验签名）

1. **校验时间戳**：服务端当前时间是 10:02，计算`10:02 - 10:00 = 2分钟 ≤ 5分钟` → 时间合法；
2. **校验 Nonce**：查 Redis，`abc123def456`不存在 → 存入 Redis（过期时间 5 分钟）；
3. **验签名**：签名合法 → 执行下单逻辑，生成 1 笔订单。

### 步骤 3：攻击者重放请求（两种场景都失效）

#### 场景 1：5 分钟内重放（Nonce 拦截）

攻击者 10:03 重放相同请求：

- 时间戳：`1734364800000` → 10:03-10:00=3 分钟 ≤5 分钟 → 时间合法；
- Nonce：`abc123def456` → 查 Redis 已存在 → 服务端拒绝：“重复请求”。

#### 场景 2：5 分钟后重放（时间戳拦截）

攻击者 10:06 重放相同请求：

- 时间戳：`1734364800000` → 10:06-10:00=6 分钟 ＞5 分钟 → 服务端拒绝：“请求已过期”。

## 四、关键细节（避坑点）

### 1. 时间戳为什么用毫秒级？

如果用秒级（比如`1734364800`），高并发下同一秒可能有多个请求，攻击者可利用 “秒级精度” 在同一秒内重放；毫秒级（`1734364800000`）能把时间精度缩到极致，几乎无法钻空子。

### 2. Nonce 为什么要存在 Redis？

- 服务端是分布式部署的话，本地内存存 Nonce 会导致 “节点 A 标记过的 Nonce，节点 B 不认识”，Redis 是分布式共享存储，所有节点都能查到；
- Nonce 必须设置过期时间（和时间戳有效期一致），比如 5 分钟，避免 Redis 里堆积海量无效 Nonce，占用内存。

### 3. 为什么要 “时间戳 + Nonce” 一起用？（缺一不可）

| 只用水印（时间戳）   | 只用身份证（Nonce）                       | 时间戳 + Nonce                                  |
| -------------------- | ----------------------------------------- | ----------------------------------------------- |
| 5 分钟内的重放拦不住 | Nonce 会无限堆积（攻击者用新 Nonce 重放） | 5 分钟内靠 Nonce 拦，5 分钟外靠时间戳拦，无死角 |

## 五、可视化总结（一张图看懂）

```plaintext
【重放攻击】
攻击者 → 截获合法请求 → 重复提交 → 服务端无防护 → 业务异常（多下单/多扣款）

【时间戳+Nonce防护】
客户端 → 请求+时间戳（5分钟有效期）+ Nonce（唯一随机串）→ 服务端
服务端 → 第一步：校验时间戳（过期？→ 拒绝）
        → 第二步：校验Nonce（已用？→ 拒绝）
        → 第三步：验签名（合法？→ 执行业务）
        → 第四步：标记Nonce为已用（Redis，5分钟过期）
→ 重复请求要么超时，要么Nonce已用，全部失效
```

简单说：**时间戳管 “请求有没有过期”，Nonce 管 “请求有没有被用过”，两者结合，就能把重放攻击堵死**。

```yaml
aliyun:
  oss:
    access-key: LTAI5txxxxxxxxxxxxxxxxx
    secret-key: 8kxxxxxxxxxxxxxxxxxxxxxx
    endpoint: oss-cn-hangzhou.aliyuncs.com
```



程序会用 SK 对上传请求进行签名，阿里云验证签名合法后，才允许上传，全程无需人工干预。

### 总结

- **用户名密码**：为人设计，侧重 “身份验证”，适合人工交互场景。
- **AK/SK**：为机器设计，侧重 “请求签名验证”，适合自动化服务调用，安全性更高、权限更精细。

在 Java 后端开发中，**绝对不要用用户名密码代替 AK/SK** 来调用第三方服务，否则会导致密码硬编码泄露、权限过大等严重安全问题。