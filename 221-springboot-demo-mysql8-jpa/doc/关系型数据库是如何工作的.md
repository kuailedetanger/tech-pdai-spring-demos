# 关系型数据库是如何工作的（深度拆解）

## 通俗 + 表格 + 图文 全解析

本文从**数据结构底层**到**数据库核心组件**，再到**查询执行全流程**，用通俗语言、对比表格、逻辑图解拆解 “关系型数据库（如 MySQL）到底是怎么工作的”，帮你从 “只会用” 升级为 “懂原理”。

## 一、前置知识：数据库的 “底层骨架”（数据结构）

数据库的高效运行，本质是靠底层数据结构支撑 —— 就像盖房子先搭钢筋骨架，先理清这些核心结构：

### 1. 基础：时间复杂度（判断算法效率的 “尺子”）

![image-20251217142255792](D:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20251217142255792.png)

| 时间复杂度 | 通俗解释                         | 数据库应用场景               |
| ---------- | -------------------------------- | ---------------------------- |
| O(1)       | 不管数据多少，操作耗时固定       | 哈希表查询、主键精准查找     |
| O(log n)   | 数据翻倍，耗时只加一点           | B + 树索引查询（MySQL 核心） |
| O(n)       | 数据翻倍，耗时也翻倍             | 全表扫描（无索引时）         |
| O(n log n) | 比 O (n) 高效，比 O (log n) 稍慢 | 归并排序、索引构建           |

### 2. 核心排序：归并排序（数据库排序的 “主力”）

- **通俗解释**：把数据拆成小块分别排序，再合并成有序整体（像整理扑克牌，先分堆理好，再合在一起）。

- **数据库作用**：`ORDER BY`、`GROUP BY`、联表查询时的排序操作，底层大多用归并排序（稳定、适合磁盘数据）。

  ```plaintext
  无序数据 [5,2,8,1] → 拆分 [5,2]、[8,1] → 子排序 [2,5]、[1,8] → 合并 [1,2,5,8]
  ```

  3. 核心查找：二叉搜索树 vs B + 树（索引的 “核心载体”）

数据库索引的核心是 B + 树，先对比它和基础二叉搜索树的差异：

| 结构       | 通俗解释                                               | 优势                                                         | 劣势                                              | 数据库应用                           |
| ---------- | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------- | ------------------------------------ |
| 二叉搜索树 | 每个节点存数据，左子树比节点小，右子树大               | 查找快（O (log n)）                                          | 易 “失衡” 成链表（O (n)）、不适合磁盘（节点分散） | 几乎不用（仅理论基础）               |
| B + 树     | 所有数据存在叶子节点，非叶子只存索引；叶子节点连成链表 | 1. 高度低（3 层可存千万数据）；2. 叶子链表适合范围查询；3. 磁盘 IO 少（节点存更多索引） | 插入 / 删除稍复杂                                 | MySQL InnoDB 索引（主键 / 二级索引） |

- B + 树索引图解

  （MySQL 主键索引）：

  ```plaintext
  根节点 [10, 20]
  /        |        \
  分支 [1-9]  分支 [11-19]  分支 [21-30]
  /          |          \
  叶子 [1,2..9]  叶子 [11..19]  叶子 [21..30]
  （叶子节点双向链表，支持范围查询：如查15-25）
  ```

  

### 4. 补充：哈希表（快速匹配，不适合范围）

- **通俗解释**：通过 “哈希函数” 把 key 映射到固定位置（像快递柜按编号存件）。
- **数据库作用**：内存临时表、哈希联接、缓存索引；缺点是不支持范围查询（如`BETWEEN`、`ORDER BY`）。

## 二、全局概览：数据库的 “核心组件”（像一个工厂）

把数据库比作 “数据处理工厂”，核心组件分工明确，先看整体架构图

```plaintext
客户端 → 客户端管理器（连接/权限）→ 查询管理器（解析/优化）→ 数据管理器（执行/存储）→ 磁盘
                                  ↑                    ↑
                                  └── 工具（日志/事务） ──┘
```

### 核心组件分工表：

| 组件大类   | 子组件         | 通俗角色   | 核心职责                                                |
| ---------- | -------------- | ---------- | ------------------------------------------------------- |
| 查询管理器 | 查询解析器     | 翻译官     | 把 SQL 翻译成数据库能懂的 “抽象语法树（AST）”，校验语法 |
|            | 查询重写器     | 文案优化师 | 优化 SQL（如把`SELECT *`改成具体字段、合并子查询）      |
|            | 统计查询优化器 | 规划师     | 基于数据统计（如行数、索引分布）选最优执行计划          |
|            | 查询执行器     | 操作工     | 执行优化后的查询计划，调用数据管理器接口                |
| 数据管理器 | 缓存管理器     | 仓库备货区 | 把热点数据放内存，减少磁盘 IO                           |
|            | 事务管理器     | 流程监督员 | 保证事务 ACID 特性（原子性 / 一致性 / 隔离性 / 持久性） |
|            | 锁管理器       | 门禁管理员 | 控制并发访问，避免数据冲突                              |
|            | 日志管理器     | 黑匣子     | 记录所有修改操作，用于故障恢复                          |

## 三、核心流程 1：数据查询的完整链路（从 SQL 输入到结果输出）

以`SELECT * FROM user WHERE id > 10 AND age < 30`为例，拆解完整流程：

### 1. 第一步：客户端管理器（接待室）

- 作用：接收客户端（Java/PHP）的连接请求，校验账号密码、分配连接（连接池）。
- 通俗解释：像工厂的门卫，核实身份后才让进。

### 2. 第二步：查询管理器（核心决策层）

#### （1）查询解析器：“翻译 SQL”

- 做什么：把 SQL 字符串解析成 AST（抽象语法树），检查语法错误（如关键字写错）。
- 例子：把`SELECT * FROM user WHERE id>10`解析成 “查询 user 表，条件 id>10” 的结构化树。

#### （2）查询重写器：“优化 SQL 写法”

- 做什么：自动优化 SQL，比如：
  - 把`SELECT *`改成`SELECT id, name`（如果只需要这两个字段）；
  - 把`WHERE id=10 OR id=20`改成`WHERE id IN (10,20)`；
  - 消除冗余子查询。

#### （3）统计查询优化器：“选最优路线”

这是查询管理器的核心，负责选择 “最快的执行方式”，关键看两点：

- **数据统计**：数据库会记录表的行数、索引分布（如 id 的最小值 / 最大值）、字段重复率；

- **存取路径选择**：

  - 索引存取：是否用 B + 树索引（如 id>10 用索引，age<30 可能不用）；

  - 联接运算符（多表联查时）：

    | 联接算法     | 通俗解释                                             | 适用场景                         |
    | ------------ | ---------------------------------------------------- | -------------------------------- |
    | 嵌套循环联接 | 外层表逐行查，内层表匹配（像查字典先找目录，再翻页） | 小表联大表（外层小表，内层索引） |
    | 哈希联接     | 把小表建成哈希表，大表逐行匹配（像按快递单号查快递） | 大表联大表（无索引）             |
    | 合并联接     | 先排序两张表，再合并匹配（像合并两个有序列表）       | 两张表都有序（或有排序索引）     |

  - **算法选择原则**：小表 + 索引→嵌套循环；大表无索引→哈希联接；有序表→合并联接。

- **优化算法**：

  - 动态规划：穷举所有可能的执行计划，选最优（适合少表联查）；
  - 贪心 / 启发式算法：只选 “看起来最优” 的方案（适合多表联查，避免穷举耗时）。

#### （4）查询计划缓存：“记下来下次用”

- 作用：把优化后的执行计划缓存起来，相同 SQL 再次执行时直接用，跳过解析 / 优化步骤。
- 注意：表数据变更（INSERT/UPDATE）会清空缓存，避免计划失效。

#### （5）查询执行器：“按计划干活”

- 作用：调用数据管理器的接口，执行查询计划（如 “读 user 表的 B + 树索引，过滤 age<30”）。

### 3. 第三步：数据管理器（数据操作层）

#### （1）缓存管理器（减少磁盘 IO 的关键）

- 核心组件：
  - 预读缓冲区：提前把磁盘上的相邻数据读入内存（比如查 id=10，顺带读 id=11-20）；
  - 置换策略：内存满了淘汰数据，主流是**LRU 改进版**（MySQL InnoDB 用 LRU_LIST，分年轻 / 年老区，避免频繁淘汰热点数据）；
  - 写缓冲区：写数据时先写内存缓冲区，批量刷到磁盘（减少磁盘写入次数）。
- 通俗解释：像超市的备货区，把常卖的货放在备货区，不用每次都去仓库（磁盘）拿。

#### （2）事务管理器 + 锁管理器（保证并发安全）

| 组件       | 核心功能                     | 关键概念                                                     |
| ---------- | ---------------------------- | ------------------------------------------------------------ |
| 事务管理器 | 控制事务的开始 / 提交 / 回滚 | ACID、隔离级别（读已提交 / 可重复读）                        |
| 锁管理器   | 控制数据访问权限             | 悲观锁（先锁再操作）、死锁（互相等对方解锁）、两段锁（先加锁，再解锁，不中途加锁） |

- 死锁例子：事务 A 锁了 id=10，要 id=20；事务 B 锁了 id=20，要 id=10 → 互相卡住，数据库会检测并回滚其中一个。

#### （3）日志管理器（保证数据不丢）

- 核心：WAL（预写式日志）—— 写数据前，先把操作记录到日志文件，再写磁盘。
- 关键概念：
  - ARIES 日志：一套恢复算法，崩溃后能通过日志恢复数据；
  - 日志缓冲区：日志先写内存缓冲区，批量刷盘；
  - STEAL 策略：允许未提交事务的数据刷到磁盘；
  - FORCE 策略：事务提交时，强制把数据刷到磁盘（MySQL 默认非 FORCE，靠缓冲区刷盘）。
- 通俗解释：像工厂的操作日志，每一步修改都记下来，就算机器坏了，也能按日志恢复。

### 4. 第四步：返回结果

执行器把数据从缓存 / 磁盘读取后，过滤、排序、合并，最终返回给客户端。

## 四、简化例子：一条 SQL 的执行全过程

以`SELECT name FROM user WHERE id=10`（InnoDB 表，id 为主键）为例：



```plaintext
1. 客户端发起请求 → 客户端管理器校验权限，分配连接；
2. 查询解析器：解析SQL为AST，确认语法正确；
3. 查询重写器：无优化（SQL已简单）；
4. 优化器：统计显示id是主键，选择B+树索引存取；
5. 执行器：调用缓存管理器，检查id=10是否在内存缓存；
   - 若在：直接读取name字段；
   - 若不在：从磁盘读B+树索引，找到id=10的叶子节点，读数据到缓存；
6. 执行器返回name给客户端；
7. 日志管理器：无修改操作，无需写日志；
8. 缓存管理器：把id=10的数据留在缓存，供后续查询使用。
```

## 五、关键问题解答

### 1. 联接算法哪个最好？

没有绝对最优，看场景：

- 小表联大表（内层有索引）→ 嵌套循环联接；
- 大表联大表（无索引）→ 哈希联接；
- 两张表都有序（或有排序索引）→ 合并联接。

### 2. 缓存置换为什么不用纯 LRU？

纯 LRU 会把 “偶尔访问一次的大数据” 当成热点，挤占内存；MySQL InnoDB 改进为 “LRU_LIST + 年轻 / 年老区”：

- 新数据先放年轻区，访问次数够了才进年老区（热点区）；
- 年轻区数据若短时间内没被访问，直接淘汰，避免占用内存。

### 3. WAL 预写日志的核心价值？

- 崩溃恢复：磁盘坏了，能通过日志重放所有操作，恢复数据；
- 提升性能：写日志（顺序写）比写磁盘（随机写）快，批量刷盘减少 IO。

## 六、核心总结（知识体系）

1. **底层基础**：B + 树（索引）、归并排序（排序）、哈希表（快速匹配）是数据库高效运行的 “骨架”；
2. **核心流程**：SQL → 解析 → 重写 → 优化（选执行计划）→ 执行（查缓存 / 磁盘）→ 返回结果；
3. **保障机制**：缓存（提性能）、锁 + 事务（保并发安全）、WAL 日志（保数据不丢）；
4. **优化关键**：查询优化器选对执行计划，缓存管理器减少磁盘 IO，联接算法适配数据规模。

理解这些原理，你就能解释：

- 为什么加索引后查询变快？（B + 树减少 IO）；
- 为什么 SQL 写得不好会慢？（优化器选了差的执行计划）；
- 为什么数据库崩溃后数据没丢？（WAL 日志恢复）。

这也是从 “SQL 使用者” 到 “数据库调优工程师” 的核心门槛。