学习文档：https://mp.weixin.qq.com/s/vPqqfUujCsmuhHT8YHxIHA

自己理解：
第一步：先懂 “关注点分离”+“只做一件事” 的核心逻辑

举个最贴近的例子：你去餐厅吃饭，整个流程会拆分给不同角色：
采购（只负责买食材，不做菜）；
厨师（只负责做菜，不收银）；
服务员（只负责传菜 / 点餐，不采购）；
收银员（只负责收钱，不做菜）。
如果让厨师又采购又收银，一旦出问题（比如算错账、买错菜），你根本不知道问题出在采购还是收银；而且厨师分心做其他事，菜也做不好。

对应到代码里：“关注点分离” 就是把系统的不同功能（数据存储、数据传输、业务处理、页面展示）拆给不同对象；“每个对象只做一件事” 就是让 PO 只管和数据库映射、DTO 只管接口数据传输、VO 只管页面展示 ——一个对象只聚焦一个核心目标，不掺杂其他职责。



第二步：结合 6 种对象，拆解 “只做一件事” 的具体体现
先给每个对象的 “核心职责” 定边界，再说明 “越界会出什么问题”，你就能直观理解这句话的价值：
对象	核心职责（只做这一件事）	通俗理解	越界的后果
PO（Persistent Object）	纯映射数据库表结构，只负责 “和数据库交互的载体”，无任何业务逻辑	数据库表的 “镜像”：表有什么字段，PO 就有什么属性，比如UserPO对应user表，字段完全一致	若在 PO 里加 “校验手机号格式”“计算年龄” 的逻辑，会导致数据库层和业务层耦合，改表结构时还要改业务逻辑，极易出错
DTO（Data Transfer Object）	只负责 “接口之间的数据传输”，比如前端传参给后端、微服务之间调参，按需封装字段（可裁剪 / 组合 PO 字段）	接口的 “快递包裹”：只装接口需要的字段，比如前端登录只传username+password，就做LoginDTO，不塞无关的id/age	若直接用 PO 当 DTO，会把数据库的敏感字段（如password明文、createTime）暴露给前端，或传输大量无用字段浪费带宽
VO（View Object）	只负责 “前端页面 / 接口返回展示”，按前端展示需求封装字段（比如格式化时间、拼接昵称）	前端的 “展示模板”：前端要显示 “用户昵称 + 注册时间（yyyy-MM-dd）”，VO 就封装nickname+formatCreateTime	若让 DTO 直接返回给前端，前端需要手动格式化时间 / 拼接字段，增加前端工作量；或后端改 DTO 时直接影响前端展示
BO（Business Object）	只负责 “封装业务逻辑”，整合多个 PO/DTO 的信息，承载核心业务规则（比如下单逻辑、库存扣减）	业务的 “处理中枢”：比如下单 BO 整合OrderPO+UserPO+GoodsPO，封装 “扣库存 + 生成订单 + 减余额” 的逻辑	若把业务逻辑散在 Controller/Service 里，或塞到 PO/DTO 中，会导致业务规则混乱，改一个逻辑要改多处
DAO（Data Access Object）	只负责 “数据库 CRUD 操作”，是 PO 和数据库之间的 “桥梁”，只做数据存取，无业务逻辑	数据库的 “操作手”：比如UserDAO只做selectById/insert/update，不管业务规则	若在 DAO 里加 “判断用户是否有权限” 的逻辑，会让数据层和业务层耦合，DAO 变成 “万能类”，难以维护
POJO（Plain Old Java Object）	最基础的 “纯属性对象”，无继承、无框架依赖，是 PO/DTO/VO/BO 的 “父类形态”，只负责封装数据（无任何逻辑）	所有对象的 “毛坯房”：只有 get/set/toString，不依赖任何框架（如 Spring、MyBatis）	若给 POJO 加框架注解（如@Controller/@Service），就不是纯 POJO 了，会和框架耦合，失去通用性
第三步：理解 “做好它” 的关键 —— 职责单一带来的好处
“每个对象只做一件事” 的最终目的，是让每个对象能 “做好这件事”，核心收益有 3 点：


