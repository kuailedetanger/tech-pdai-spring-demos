# 常用线程API方法：通俗讲解+表格+图文

### 一、核心逻辑铺垫

先回归之前的 “工人（Thread）” 场景：



* 线程 = 工厂里的工人，每个工人有自己的 “状态”（空闲、干活中、休息、下班）

* 线程 API = 工人的 “操作指令”（让他开工、休息、暂停、下班等）

### 二、常用线程 API 方法（通俗讲解 + 表格）

#### 核心 API 方法对比表



| API 方法                               | 通俗含义（工人场景）             | 作用说明                                             | 注意事项                                              |
| ------------------------------------ | ---------------------- | ------------------------------------------------ | ------------------------------------------------- |
| `start()`                            | 给工人发 “开工指令”            | 启动线程，JVM 自动调用`run()`方法                           | 1. 不能重复调用（工人不能重复开工）；2. 直接调用`run()`只是普通方法，不启动线程    |
| `run()`                              | 工人 “干活的具体内容”           | 线程执行的核心逻辑（任务本身）                                  | 无需手动调用，由`start()`触发                               |
| `sleep(long millis)`                 | 让工人 “强制休息指定时间”（毫秒）     | 线程休眠，期间不释放锁（比如手里拿着工具）                            | 1. 休眠时间到后进入就绪状态；2. 需处理`InterruptedException`（被叫醒） |
| `join()` / `join(long)`              | 让其他工人 “等我干完再开工”        | 等待当前线程执行完毕，再执行其他线程                               | 1. 无参：一直等；2. 有参：最多等指定毫秒；3. 需处理中断异常                |
| `yield()`                            | 工人 “主动让个步”，让其他工人先干     | 线程主动放弃 CPU 执行权，进入就绪状态                            | 只是 “建议”，CPU 不一定采纳（工人让了步，领导可能不让）                   |
| `interrupt()`                        | 给休眠 / 等待的工人发 “叫醒指令”    | 中断线程（不是强制停止，只是发通知）                               | 1. 线程运行中调用：仅设置 “中断标志”；2. 线程休眠 / 等待中调用：抛出中断异常      |
| `isInterrupted()`                    | 检查工人 “是否收到过叫醒指令”       | 判断线程是否被中断（不清除中断标志）                               | 不会改变线程的中断状态                                       |
| `interrupted()`                      | 检查并 “清空叫醒指令”           | 判断线程是否被中断（会清除中断标志）                               | 静态方法，返回后中断标志重置为 false                             |
| `currentThread()`                    | 查看 “当前正在干活的工人是谁”       | 获取当前执行代码的线程对象                                    | 静态方法，常用在`Runnable`中获取线程信息                         |
| `getName()` / `setName()`            | 给工人 “起名 / 查名字”         | 设置 / 获取线程名称（方便调试）                                | 建议给线程命名，避免默认的 Thread-0/1/2...                     |
| `getPriority()` / `setPriority(int)` | 给工人 “定优先级”（1-10）       | 设置线程优先级，优先级高的线程更易获 CPU                           | 1. 默认优先级 5；2. 只是 “概率优先”，不是绝对先执行                   |
| `isAlive()`                          | 检查工人 “是否在干活 / 待命”（没下班） | 判断线程是否处于存活状态（就绪 / 运行中）                           | 线程执行完`run()`后，状态变为死亡，返回 false                     |
| `setDaemon(boolean)`                 | 把工人设为 “临时工”（守护线程）      | 1. 守护线程依赖主线程，主线程结束它就结束；2. 非守护线程（用户线程）：主线程结束也会干完活 | 1. 必须在`start()`前设置；2. 不能用于执行核心任务（比如保存数据）          |

#### 重点方法通俗拆解



1. `start()`**&#x20;vs&#x20;**`run()`**：关键区别**

* 错误做法：`worker.run()` → 相当于让工人 “坐着不动干话”，只是普通方法调用，没有启动新线程（全靠主线程干）；

* 正确做法：`worker.start()` → 相当于给工人分配独立工位，工人自己干（启动新线程），JVM 自动调用`run()`。

* 示意图：



```
调用start()：主线程 → 启动子线程 → 子线程执行run()

调用run()：主线程 → 直接执行run()（无新线程）
```



1. `sleep()`**&#x20;vs&#x20;**`yield()`**：休息 vs 让步**

* `sleep(1000)`：工人必须休息 1 秒，期间不干活，1 秒后再等 CPU 分配（手里的工具不放下，锁不释放）；

* `yield()`：工人说 “我先歇会，你们来”，但 CPU 可能不让（比如没其他工人干活），立马又继续干（释放 CPU 但不释放锁）。

1. `join()`**：等待协作**

* 场景：工人 A 要等工人 B 生产完零件，才能组装。

* 代码示例：



```
Thread workerB = new Thread(() -> System.out.println("B生产零件"));

Thread workerA = new Thread(() -> {

&#x20;   try {

&#x20;       workerB.join(); // A等B干完

&#x20;       System.out.println("A组装零件");

&#x20;   } catch (InterruptedException e) {

&#x20;       e.printStackTrace();

&#x20;   }

});

workerB.start();

workerA.start();

// 执行结果：先打印“B生产零件”，再打印“A组装零件”
```



1. **守护线程（**`setDaemon(true)`**）：临时工特性**

* 场景：主线程是 “工厂老板”，守护线程是 “清洁工”（临时工）。

* 逻辑：老板下班（主线程结束），清洁工不管有没有打扫完，都得立马下班；如果是正式工（非守护线程），老板下班了，正式工得干完活再走。

* 示例：



```
Thread cleaner = new Thread(() -> {

&#x20;   while (true) {

&#x20;       System.out.println("清洁工打扫卫生");

&#x20;       try {

&#x20;           Thread.sleep(500);

&#x20;       } catch (InterruptedException e) {

&#x20;           e.printStackTrace();

&#x20;       }

&#x20;   }

});

cleaner.setDaemon(true); // 设为守护线程

cleaner.start();

Thread.sleep(2000); // 老板（主线程）干2秒活

System.out.println("老板下班了");

// 结果：主线程结束后，清洁工停止打扫（即使while(true)）
```

### 三、线程状态流转（图文理解 API 的作用）

#### 线程状态流转示意图（通俗版）



```mermaid
graph LR
    A[新建状态（工人刚招聘）] -->|调用start()| B[就绪状态（工人待命，等CPU）]
    B -->|CPU分配执行权| C[运行状态（工人干活，执行run()）]
    C -->|调用sleep()/join()| D[阻塞状态（工人休息/等待）]
    D -->|休眠结束/等待完成| B[就绪状态]
    C -->|调用yield()| B[就绪状态]
    C -->|run()执行完毕| E[死亡状态（工人下班）]
    D -->|调用interrupt()| F[抛出中断异常]
    F --> B[就绪状态]
```



* 每个 API 对应状态流转：


  * `start()`：A→B；

  * `sleep()`/`join()`：C→D；

  * `yield()`：C→B；

  * `interrupt()`：D→F→B；

  * `run()`结束：C→E。

### 四、通俗避坑指南



1. 别重复调用`start()`：工人不能二次开工，会抛`IllegalThreadStateException`；

2. 别用`stop()`（已过时）：相当于 “强制解雇工人”，可能导致资源泄露（比如工具没放下），用`interrupt()`+ 中断标志控制线程停止；

3. `sleep()`不释放锁：工人休息时手里拿着工具，其他人用不了；

4. 守护线程别干核心活：比如临时工不能负责保存生产数据，老板下班他就停了，会丢数据。

> （注：文档部分内容可能由 AI 生成）





# ***\*获取线程\*******\*对象以及名称\****

| **常用线程****api方法**          |                                                    |
| -------------------------------- | -------------------------------------------------- |
| start()                          | 启动线程                                           |
| currentThread()                  | 获取当前线程对象                                   |
| getID()                          | 获取当前线程ID   Thread-编号 该编号从0开始         |
| getName()                        | 获取当前线程名称                                   |
| sleep(long mill)                 | 休眠线程                                           |
| Stop（）                         | 停止线程                                           |
| **常用线程构造****函数**         |                                                    |
| Thread（）                       | 分配一个新的 Thread 对象                           |
| Thread（String name）            | 分配一个新的 Thread对象，具有指定的 name正如其名。 |
| Thread（Runable r）              | 分配一个新的 Thread对象                            |
| Thread（Runable r, String name） | 分配一个新的 Thread对象                            |

# 多线程运行状态

![img](file:///D:\Users\ADMINI~1\AppData\Local\Temp\ksohtml32572\wps1.png) 

 线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。